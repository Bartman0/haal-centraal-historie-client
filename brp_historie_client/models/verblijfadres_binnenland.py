# coding: utf-8

"""
    BRP historie bevragen

    API voor het zoeken en raadplegen van historische verblijfplaatsen, partners, nationaliteiten en verblijfstitels uit de BRP (inclusief de RNI).  Zie de [Functionele documentatie](https://github.com/VNG-Realisatie/Haal-Centraal-BRP-historie-bevragen/tree/v1.0.0/features) voor nadere toelichting. 

    The version of the OpenAPI document: 2.0.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from typing_extensions import Annotated
from brp_historie_client.models.verblijfadres_binnenland_in_onderzoek import VerblijfadresBinnenlandInOnderzoek
from brp_historie_client.models.waardetabel import Waardetabel
from typing import Optional, Set
from typing_extensions import Self

class VerblijfadresBinnenland(BaseModel):
    """
    VerblijfadresBinnenland
    """ # noqa: E501
    officiele_straatnaam: Optional[Annotated[str, Field(strict=True, max_length=80)]] = Field(default=None, description="De officiële naam van een openbare ruimte uit de Basisregistratie Gebouwen en Adressen (BAG). ", alias="officieleStraatnaam")
    korte_straatnaam: Optional[Annotated[str, Field(strict=True, max_length=24)]] = Field(default=None, description="De officiële naam van een openbare ruimte uit de Basisregistratie Gebouwen en Adressen (BAG), zo nodig verkort tot maximaal 24 tekens, of de straatnaam van een niet-BAG adres. ", alias="korteStraatnaam")
    huisnummer: Optional[Annotated[int, Field(le=99999, strict=True, ge=1)]] = Field(default=None, description="Een nummer dat door de gemeente aan een adresseerbaar object is gegeven. ")
    huisletter: Optional[Annotated[str, Field(strict=True)]] = Field(default=None, description="Een toevoeging aan een huisnummer in de vorm van een letter die door de gemeente aan een adresseerbaar object is gegeven. ")
    huisnummertoevoeging: Optional[Annotated[str, Field(strict=True)]] = Field(default=None, description="Een toevoeging aan een huisnummer of een combinatie van huisnummer en huisletter die door de gemeente aan een adresseerbaar object is gegeven. ")
    aanduiding_bij_huisnummer: Optional[Waardetabel] = Field(default=None, alias="aanduidingBijHuisnummer")
    postcode: Optional[Annotated[str, Field(strict=True)]] = Field(default=None, description="De door PostNL vastgestelde code die bij een bepaalde combinatie van een straatnaam en een huisnummer hoort. ")
    woonplaats: Optional[Annotated[str, Field(strict=True)]] = Field(default=None, description="Een woonplaats is een gedeelte van het grondgebied van de gemeente met een naam. ")
    in_onderzoek: Optional[VerblijfadresBinnenlandInOnderzoek] = Field(default=None, alias="inOnderzoek")
    __properties: ClassVar[List[str]] = ["officieleStraatnaam", "korteStraatnaam", "huisnummer", "huisletter", "huisnummertoevoeging", "aanduidingBijHuisnummer", "postcode", "woonplaats", "inOnderzoek"]

    @field_validator('huisletter')
    def huisletter_validate_regular_expression(cls, value):
        """Validates the regular expression"""
        if value is None:
            return value

        if not re.match(r"^[a-zA-Z]{1}$", value):
            raise ValueError(r"must validate the regular expression /^[a-zA-Z]{1}$/")
        return value

    @field_validator('huisnummertoevoeging')
    def huisnummertoevoeging_validate_regular_expression(cls, value):
        """Validates the regular expression"""
        if value is None:
            return value

        if not re.match(r"^[a-zA-Z0-9 \-]{1,4}$", value):
            raise ValueError(r"must validate the regular expression /^[a-zA-Z0-9 \-]{1,4}$/")
        return value

    @field_validator('postcode')
    def postcode_validate_regular_expression(cls, value):
        """Validates the regular expression"""
        if value is None:
            return value

        if not re.match(r"^[1-9]{1}[0-9]{3}[ ]?[A-Za-z]{2}$", value):
            raise ValueError(r"must validate the regular expression /^[1-9]{1}[0-9]{3}[ ]?[A-Za-z]{2}$/")
        return value

    @field_validator('woonplaats')
    def woonplaats_validate_regular_expression(cls, value):
        """Validates the regular expression"""
        if value is None:
            return value

        if not re.match(r"^[a-zA-Z0-9À-ž \(\)\,\.\-\\']{1,80}$", value):
            raise ValueError(r"must validate the regular expression /^[a-zA-Z0-9À-ž \(\)\,\.\-\']{1,80}$/")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of VerblijfadresBinnenland from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of aanduiding_bij_huisnummer
        if self.aanduiding_bij_huisnummer:
            _dict['aanduidingBijHuisnummer'] = self.aanduiding_bij_huisnummer.to_dict()
        # override the default output from pydantic by calling `to_dict()` of in_onderzoek
        if self.in_onderzoek:
            _dict['inOnderzoek'] = self.in_onderzoek.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of VerblijfadresBinnenland from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "officieleStraatnaam": obj.get("officieleStraatnaam"),
            "korteStraatnaam": obj.get("korteStraatnaam"),
            "huisnummer": obj.get("huisnummer"),
            "huisletter": obj.get("huisletter"),
            "huisnummertoevoeging": obj.get("huisnummertoevoeging"),
            "aanduidingBijHuisnummer": Waardetabel.from_dict(obj["aanduidingBijHuisnummer"]) if obj.get("aanduidingBijHuisnummer") is not None else None,
            "postcode": obj.get("postcode"),
            "woonplaats": obj.get("woonplaats"),
            "inOnderzoek": VerblijfadresBinnenlandInOnderzoek.from_dict(obj["inOnderzoek"]) if obj.get("inOnderzoek") is not None else None
        })
        return _obj


